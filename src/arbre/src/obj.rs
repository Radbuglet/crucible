use std::hash;
use std::intrinsics::type_id;
use std::num::NonZeroU64;
use std::ops::Deref;
use std::ptr::{from_raw_parts, DynMetadata, Pointee};
use crate::util::{ref_addr, AnyValue, PhantomInvariant, PerfectMap, ConstVec};

// === Keys === //

/// An untyped component identifier underlying [Key].
// We assume that type IDs are non-zero because getting that exact ID is exceedingly unlikely and
// doing so enables specific memory and performance optimizations in `PerfectMap`.
#[derive(Hash, Eq, PartialEq, Copy, Clone)]
pub struct RawKey(NonZeroU64);

impl RawKey {
    pub const fn new<T: ?Sized + 'static>() -> Self {
        if let Some(id) = NonZeroU64::new(type_id::<T>()) {
            Self (id)
        } else {
            panic!("RawKey had a TypeId of `0`, breaking `PerfectMap`'s invariants. This is \
                    exceedingly rare and a recompile should fix this once in a lifetime occurrence.");
        }
    }

    const fn map_key(self) -> NonZeroU64 {
        self.0
    }
}

/// A unique identifier for a component of type `T`.
pub struct Key<T: ?Sized> {
    /// Marker to bind the `T` generic parameter. Parameter lifetime is invariant because users could
    /// potentially provide keys with an insufficient lifetime.
    _ty: PhantomInvariant<T>,

    /// The program unique identifier of the key.
    raw_id: RawKey,
}

impl<T: ?Sized + 'static> Key<T> {
    /// Constructs the singleton key for the specified component type. As per [TypeId]'s
    /// limitations, this type must live for `'static`.
    pub const fn typed() -> Self {
        Self {
            _ty: PhantomInvariant::new(),
            raw_id: RawKey::new::<T>(),
        }
    }
}

impl<T: ?Sized> Key<T> {
    /// Promotes a [RawKey] to a typed [Key]. This operation is super unsafe. To create new keys safely,
    /// use the [new_key] macro instead.
    ///
    /// ## Safety
    ///
    /// A given [RawId] must only ever be associated with a single type `T` and failing to do so will
    /// cause unsoundness in the type system.
    ///
    pub const unsafe fn new_unchecked(raw_id: RawKey) -> Self {
        Self {
            _ty: PhantomInvariant::new(),
            raw_id,
        }
    }

    pub const fn raw(self) -> RawKey {
        self.raw_id
    }
}

impl<T: ?Sized> hash::Hash for Key<T> {
    fn hash<H: hash::Hasher>(&self, state: &mut H) {
        self.raw_id.hash(state)
    }
}

impl<T: ?Sized> Eq for Key<T> {}
impl<T: ?Sized> PartialEq for Key<T> {
    fn eq(&self, other: &Self) -> bool {
        self.raw_id.eq(&other.raw_id)
    }
}

impl<T: ?Sized> Copy for Key<T> {}
impl<T: ?Sized> Clone for Key<T> {
    fn clone(&self) -> Self {
        Self {
            _ty: PhantomInvariant::new(),
            raw_id: self.raw_id,
        }
    }
}

/// Constructs a brand new `Key` to a component of the specified type.
///
/// ## Syntax
///
/// ```no_run
/// new_key!(
///     $type:ty  // The type of the component
/// );
/// ```
///
pub macro new_key($type:ty) {
    unsafe {
        struct UniqueTy;

        // Safety: `UniqueTy` is guaranteed to be a unique type.
        Key::<$type>::new_unchecked(RawKey::new::<UniqueTy>())
    }
}

// === V-Tables === //

const TABLE_BUCKETS: usize = 32;
const MAX_COMPS: usize = 16;

pub struct RawVTable {
    map: PerfectMap<RawVTableEntry, { TABLE_BUCKETS }>,
}

impl RawVTable {
    pub fn resolve(&self, key: RawKey) -> Option<&RawVTableEntry> {
        self.map.get(key.map_key())
    }
}

#[derive(Copy, Clone)]
pub struct RawVTableEntry {
    /// The offset to the actual object's address.
    offset: usize,

    /// The pointer's metadata (unit if the pointer is thin).
    // All `dyn` metadata currently has the same size and layout. Let's hope it stays that way.
    // Technically, `AnyValue` can store all current forms of metadata generated by the compiler but
    // I wouldn't rely on that remaining true.
    meta: AnyValue<DynMetadata<()>>,
}

pub struct VTableFrag<S, R: ?Sized> {
    _ty: PhantomInvariant<(S, R)>,
    entries: ConstVec<RawVTableEntry, { MAX_COMPS }>,
}

impl<S, R: ?Sized> VTableFrag<S, R> {
    pub const fn new() -> Self {
        todo!()
    }

    pub const fn has(&self) {
        todo!()
    }

    pub const fn get(&self) {
        todo!()
    }

    pub const fn iter(&self) {
        todo!()
    }

    pub const fn with(&mut self) {
        todo!()
    }

    pub const fn without(&mut self) {
        todo!()
    }

    pub const fn merge(&mut self) {
        todo!()
    }

    pub const fn extend(&mut self) {
        todo!()
    }

    pub const fn build(&self) -> RawVTable {
        todo!()
    }

    pub const fn clone(&self) -> Self {
        todo!()
    }
}

pub struct VTableEntry<S, V: ?Sized> {
    _ty: PhantomInvariant<(S, V)>,
    raw: RawVTableEntry,
}

// === Obj Runtime === //

/// Specifies the root `Obj` type required by the specific component when creating a `CompRef`. All
/// types receive `type Root = dyn Obj` as a default, allowing a `CompRef` to be created with an
/// arbitrary root parameter but this can be overridden.
pub trait Comp {
    type Root: ?Sized;
}

impl<T: ?Sized> Comp for T {
    default type Root = dyn Obj;
}

// TODO: I think this can become non-static with a bit of lifetime finking.
pub unsafe trait Obj: 'static {
    // TODO: Migrate to associated variable constants once available.
    fn table(&self) -> &'static RawVTable;
}

pub trait DynObjConvert {
    fn to_dyn(&self) -> &dyn Obj;
    unsafe fn from_dyn(obj: &dyn Obj) -> &Self;
}

impl DynObjConvert for dyn Obj {
    fn to_dyn(&self) -> &dyn Obj {
        self
    }

    unsafe fn from_dyn(obj: &dyn Obj) -> &Self {
        obj
    }
}

impl<T: Sized + Obj> DynObjConvert for T {
    fn to_dyn(&self) -> &dyn Obj {
        self
    }

    unsafe fn from_dyn(obj: &dyn Obj) -> &Self {
        &*ref_addr(obj).cast::<T>()
    }
}

pub struct CompRef<'a, T: ?Sized> {
    root: &'a (dyn Obj + 'static),
    comp: &'a T,
}

impl<'a, T: Comp> CompRef<'a, T> where T::Root: DynObjConvert {
    pub fn new(root: &'a T::Root, comp: &'a T) -> Self {
        Self {
            root: root.to_dyn(),
            comp
        }
    }

    pub fn root(&self) -> &'a T::Root {
        unsafe { T::Root::from_dyn(self.root) }
    }
}

impl<'a, T: ?Sized> CompRef<'a, T> {
    pub unsafe fn new_unsafe(root: &'a (dyn Obj + 'static), comp: &'a T) -> Self {
        Self { root, comp }
    }

    pub fn root_raw(&self) -> &'a dyn Obj {
        self.root
    }

    pub fn comp(&self) -> &'a T {
        self.comp
    }
}

impl<T: ?Sized + Comp> Deref for CompRef<'_, T> {
    type Target = T;

    fn deref(&self) -> &Self::Target {
        self.comp
    }
}

impl<T: ?Sized> Copy for CompRef<'_, T> {}
impl<T: ?Sized> Clone for CompRef<'_, T> {
    fn clone(&self) -> Self {
        Self { root: self.root, comp: self.comp }
    }
}

pub trait ObjExt {
    fn try_fetch_key<T: ?Sized + Comp<Root = Self>>(&self, key: Key<T>) -> Option<CompRef<T>>;

    fn fetch_key<T: ?Sized + Comp<Root = Self>>(&self, key: Key<T>) -> CompRef<T> {
        self.try_fetch_key(key).unwrap()
    }

    unsafe fn fetch_key_unchecked<T: ?Sized + Comp<Root = Self>>(&self, key: Key<T>) -> CompRef<T> {
        self.try_fetch_key(key).unwrap_unchecked()
    }

    fn has_key<T: ?Sized + Comp<Root = Self>>(&self, key: Key<T>) -> bool {
        self.try_fetch_key(key).is_some()
    }

    fn try_fetch<T: ?Sized + 'static + Comp<Root = Self>>(&self) -> Option<CompRef<T>> {
        self.try_fetch_key(Key::<T>::typed())
    }

    fn fetch<T: ?Sized + 'static + Comp<Root = Self>>(&self) -> CompRef<T> {
        self.fetch_key(Key::<T>::typed())
    }

    unsafe fn fetch_unchecked<T: ?Sized + 'static + Comp<Root = Self>>(&self) -> CompRef<T> {
        self.fetch_key_unchecked(Key::<T>::typed())
    }

    fn has<T: ?Sized + 'static + Comp<Root = Self>>(&self) -> bool {
        self.has_key(Key::<T>::typed())
    }
}

impl<A: ?Sized + Obj + DynObjConvert> ObjExt for A {
    fn try_fetch_key<'a, T: ?Sized + Comp<Root = Self>>(&'a self, key: Key<T>) -> Option<CompRef<'a, T>> {
        self.table().resolve(key.raw())
            .map(|entry| {
                // Resolve field reference
                let field: &'a T = unsafe {
                    let addr = ref_addr(self).add(entry.offset);
                    let meta = entry.meta.get::<<T as Pointee>::Metadata>();
                    &*(from_raw_parts::<T>(addr, meta))
                };

                // Construct `CompRef`
                unsafe { CompRef::new_unsafe(self.to_dyn(), field) }
            })
    }
}
